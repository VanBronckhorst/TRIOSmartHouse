class EMS(const MAX_FROM_HEM):
signature:
	visible: 

	domains:
		Resp: {Go,Warn};


	items:


	event washControl();

	state washPower(natural);

	event msgToWash(Resp);

	event ovenControl();

	state ovenPower(natural);

	state legacyPower1(natural);

	state windmillPower(natural);

	state solarPower(natural);

	state overflow;

	state hemPower(natural);

	state consumption(natural);

	state max(natural);

	state blackoutReceive;

	state termalData(natural,integer);

	state termTreshold(natural,integer);

	state termPowerConsumption(natural);

	state roomHeating(natural);

	state batteryPowerErogated(real);

	state batteryFull;



	axioms:
		formulae:

		ConsumptionDefinition:
		consumption(i) <-> washPower(a1) & ovenPower(a2) & legacyPower1(a3) & termPowerConsumption(a4) (i=a1+a2+a3+a4)  &
		production(i) <-> windmillPower(a1) & solarPower(a2) & (i=a1+a2)  &
		max(i) <-> production(a) & batteryPowerErogated(b) & (i = a + b + MAX_FROM_HEM);

		ResponsesFromEMS:

		washControl(i,May,p,t,s,d,sh,b) & consumption(cons) & (cons + p < max) -> (msgToWash(Go) & washPower(p)) &
		washControl(i,Must,p,t,s,d,sh,b) -> msgToWash(Go) & washPower(p) &
		washControl(i,May,p,t,s,d,sh,0) & consumption(cons) & (cons + p > max) -> msgToWash(Warn) & washPower(0) &

		ovenControl(i,Must,p,t,s,d,sh,b) -> msgToOven(Go) & ovenPower(p)

		PowerBalance:
		consumption(con) & production(prod) & hemPower(bought) -> con=production+bought  &
		(washPower + ovenPower + legacyPower1 <= windmillPower + solarPower ) -> (hemPower=0) &
		(hemPower>=MAX_FROM_HEM) -> overflow &
		(washPower(nowWash) + ovenPower(nowOven) + legacyPower1(nowLegacy) < windmillPower(nowWind) + solarPower(nowSolar)) & not (batteryFull) -> chargeBattery(i) & i=nowWind+nowSolar) ;

		OverflowMeasuresShed:
		overflow & washState(i,t) & SomP(washControl(i,May,p,t,s,d,1,b)) ->  msgToWash(Warn) & washPower(0);

		OverflowMeasuresShift:
		overflow & washState(i,t) & SomP(washControl(i,May,p,t,s,d,sh,b)) & s>1 & washPower(i) & i>0 -> (Lasts(washPower(0),d) | WithinF(consumption+p<max,d) ) &
		consumption(cons) & (cons+p<max) & washState(i,t) & SomP(washControl(i,May,p,t,s,d,sh,b)) & s>1 & t>0 & washPower(0) -> washPower(p)

		OverflowMeasuresBalance:
		overflow & washState(i,t) & SomP(washControl(i,May,p,t,s,d,sh,1)) & washPower(nowWash) & nowWash >0 & max(tot )& ex(z)(z>0 & z<p & consumption(now) & (now-nowWash+z=tot) )  -> washPower(z)
		overflow & ex(i)(roomHeating(i) & termPowerConsumption(nowTerm) & nowTerm > 0  & max(tot) & ex(z) (z>0 & consumption(now) & (now-nowTerm+z<=tot)) -> termPowerConsumption(z)


		OnBlackout:
		blackoutReceive -> consumption(0) & msgToWash(Warn) & msgToOven(Warn) & ...;

		TermalAlarm:
		ex(i,t,t2)(termalData(i,t) & termTreshold(i,t2) & t<t2) <-> roomHeating(i)




